# 代理模式

## 目标

解决直接访问对象可能遇到问题，对象粗黄健成本高、需要安全控制或远程访问。

## 原理

创建一个代理类，作为真实对象的中间层，代理类持有真实对象的引用并在访问中进行控制。

代理对象和被代理对象实现同一个接口

## 与适配器模式和装饰器模式的区别

代理模式用于控制对对象的访问；适配器模式用于让不兼容的接口可以协同工作；装饰器模式动态的为对象添加行为。

## 静态代理

代理类和被代理类实现一个接口：

```java
public class RealImage implements Image {
 
   private String fileName;
 
   public RealImage(String fileName){
      this.fileName = fileName;
      loadFromDisk(fileName);
   }
 
   @Override
   public void display() {
      System.out.println("Displaying " + fileName);
   }
 
   private void loadFromDisk(String fileName){
      System.out.println("Loading " + fileName);
   }
}
```

```java
public class ProxyImage implements Image{
 
   private RealImage realImage;
   private String fileName;
 
   public ProxyImage(String fileName){
      this.fileName = fileName;
   }
 
   @Override
   public void display() {
      if(realImage == null){
         realImage = new RealImage(fileName);
      }
      realImage.display();
   }
}
```

```java
public class ProxyPatternDemo {
   
   public static void main(String[] args) {
      Image image = new ProxyImage("test_10mb.jpg");
 
      // 图像将从磁盘加载
      image.display(); 
      System.out.println("");
      // 图像不需要从磁盘加载
      image.display();  
   }
}
```

## 动态代理

### JDK动态代理

代理对象不需要实现接口，但是目标对象要实现，利用JDK的api动态的在内存中构建代理对象。

即使用java.lang.reflect.Proxy中的newProxyInstance方法来动态创建目标对象。

loader-当前对象的类加载器

interfaces-对象实现的接口类型

InvocationHandler-执行目标对象方法时候会触发事情处理器，把当前执行的目标对象方法作为参数传入。

```java
static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h )
```

示例：在上面spring下的文件夹里。

### CGLIB动态代理

cglib就不需要实现接口，而是在内存创建一个子类对象从而事先目标功能的扩展。因为是通过实现子类，所以代理的类不能为final，否则会报错java.lang.IllegalArgumentException.如果目标对象的方法为final或者static就不会被拦截。

示例：在上面spring下的文件夹里


### jdk代理与cglib代理比较

jdk代理是JDK原生的；必须要实现接口，而且也只能解决实现接口的动态代理。

cglib代理在字节码的基础上，目标对象必须是非final的，方法也有相应的子父类继承的限制，非final非static。

jdk更快。
