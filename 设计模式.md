# 创建型

## 工厂方法

**工厂模式** （Factory Pattern）通常指的是工厂方法模式（Factory Method Pattern），它定义了一个创建对象的方法，由子类决定要实例化的类。工厂方法让类的实例化推迟到子类。

抽象类：

```java
public abstarct OrderPizza{
 abstract Pizza createPizza();
}
```

抽象工厂-将具体的实现交给子类，这样有需要新增的产品直接一个新的子类实现就可以了。

```java
public class LDOrderPizza extends OrderPizza {
       Pizza createPizza(String ordertype) {
              Pizza pizza =  new LDCheesePizza();
              return pizza;
       }
}
public class NYOrderPizza extends OrderPizza {
 
	Pizza createPizza(String ordertype) {
		Pizza pizza = new NYCheesePizza();
		return pizza;
	}
 
}
```

## 抽象工厂方法

**抽象工厂模式** （Abstract Factory Pattern）提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。抽象工厂允许客户端使用抽象的接口来创建一组相关的产品，而不需要知道（或关心）实际生产的具体产品是什么。

抽象工厂的问题：

1. 当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。
2. 当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。
3. 当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。

接口：

```java
public interface IProductFactory {

    /**
     * 生产手机
     * @return
     */
    IPhoneProduct produceTelPhone();

    /**
     * 生产路由器
     * @return
     */
    IRouterProduct produceRouter();
}
```

```java
public class HuaweiProductFactory implements IProductFactory{
    @Override
    public IPhoneProduct produceTelPhone() {
        System.out.println(">>>>>>生产华为手机");
        return new HuaweiPhone();
    }

    @Override
    public IRouterProduct produceRouter() {
        System.out.println(">>>>>>生产华为路由器");
        return new HuaweiRouter();
    }

    @Override
    public IComputer produceComput() {
        return null;
    }
}
```


## 单例模式

懒汉式和饿汉式

饿汉式：

```java
public class SingleObj {
    private static volatile SingleObj singleObj = new SingleObj();
    private SingleObj(){}
    public static SingleObj getSingleObj(){
        return singleObj;
    }
}
```

线程安全的懒汉式：

```java
public class SingleObj {
    private static volatile SingleObj singleObj;
    private SingleObj(){}
    public static SingleObj getSingleObj(){
        if(singleObj==null){
            synchronized (SingleObj.class){
                if(singleObj == null){
                    singleObj = new SingleObj();
                }
            }
        }
        return singleObj;
    }
}
```

## 建造者模式


## 原型模式

# 结构型

## 适配器模式

## 装饰器模式

## 代理模式

### 目标

解决直接访问对象可能遇到问题，对象粗黄健成本高、需要安全控制或远程访问。

### 原理

创建一个代理类，作为真实对象的中间层，代理类持有真实对象的引用并在访问中进行控制。

代理对象和被代理对象实现同一个接口

### 与适配器模式和装饰器模式的区别

代理模式用于控制对对象的访问；适配器模式用于让不兼容的接口可以协同工作；装饰器模式动态的为对象添加行为。

### 静态代理

代理类和被代理类实现一个接口：

```java
public class RealImage implements Image {
 
   private String fileName;
 
   public RealImage(String fileName){
      this.fileName = fileName;
      loadFromDisk(fileName);
   }
 
   @Override
   public void display() {
      System.out.println("Displaying " + fileName);
   }
 
   private void loadFromDisk(String fileName){
      System.out.println("Loading " + fileName);
   }
}
```

```java
public class ProxyImage implements Image{
 
   private RealImage realImage;
   private String fileName;
 
   public ProxyImage(String fileName){
      this.fileName = fileName;
   }
 
   @Override
   public void display() {
      if(realImage == null){
         realImage = new RealImage(fileName);
      }
      realImage.display();
   }
}
```

```java
public class ProxyPatternDemo {
   
   public static void main(String[] args) {
      Image image = new ProxyImage("test_10mb.jpg");
 
      // 图像将从磁盘加载
      image.display(); 
      System.out.println("");
      // 图像不需要从磁盘加载
      image.display();  
   }
}
```

### 动态代理

#### JDK动态代理

代理对象不需要实现接口，但是目标对象要实现，利用JDK的api动态的在内存中构建代理对象。

即使用java.lang.reflect.Proxy中的newProxyInstance方法来动态创建目标对象。

loader-当前对象的类加载器

interfaces-对象实现的接口类型

InvocationHandler-执行目标对象方法时候会触发事情处理器，把当前执行的目标对象方法作为参数传入。

```java
static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h )
```

示例：在上面spring下的文件夹里。

#### CGLIB动态代理

cglib就不需要实现接口，而是在内存创建一个子类对象从而事先目标功能的扩展。因为是通过实现子类，所以代理的类不能为final，否则会报错java.lang.IllegalArgumentException.如果目标对象的方法为final或者static就不会被拦截。

示例：在上面spring下的文件夹里

#### jdk代理与cglib代理比较

jdk代理是JDK原生的；必须要实现接口，而且也只能解决实现接口的动态代理。

cglib代理在字节码的基础上，目标对象必须是非final的，方法也有相应的子父类继承的限制，非final非static。

jdk更快。

## 外观模式

## 桥接模式

## 组合模式

## 享元模式

# 行为型

## 策略模式

## 模板方法模式

## 观察者模式

## 迭代子模式

## 责任链模式

## 命令模式

## 备忘录模式

## 状态模式

## 访问者模式

## 中介者模式

## 解释器模式


# 代理模式

## 目标

解决直接访问对象可能遇到问题，对象粗黄健成本高、需要安全控制或远程访问。

## 原理

创建一个代理类，作为真实对象的中间层，代理类持有真实对象的引用并在访问中进行控制。

代理对象和被代理对象实现同一个接口

## 与适配器模式和装饰器模式的区别

代理模式用于控制对对象的访问；适配器模式用于让不兼容的接口可以协同工作；装饰器模式动态的为对象添加行为。

## 静态代理

代理类和被代理类实现一个接口：

```java
public class RealImage implements Image {
 
   private String fileName;
 
   public RealImage(String fileName){
      this.fileName = fileName;
      loadFromDisk(fileName);
   }
 
   @Override
   public void display() {
      System.out.println("Displaying " + fileName);
   }
 
   private void loadFromDisk(String fileName){
      System.out.println("Loading " + fileName);
   }
}
```

```java
public class ProxyImage implements Image{
 
   private RealImage realImage;
   private String fileName;
 
   public ProxyImage(String fileName){
      this.fileName = fileName;
   }
 
   @Override
   public void display() {
      if(realImage == null){
         realImage = new RealImage(fileName);
      }
      realImage.display();
   }
}
```

```java
public class ProxyPatternDemo {
   
   public static void main(String[] args) {
      Image image = new ProxyImage("test_10mb.jpg");
 
      // 图像将从磁盘加载
      image.display(); 
      System.out.println("");
      // 图像不需要从磁盘加载
      image.display();  
   }
}
```

## 动态代理

### JDK动态代理

代理对象不需要实现接口，但是目标对象要实现，利用JDK的api动态的在内存中构建代理对象。

即使用java.lang.reflect.Proxy中的newProxyInstance方法来动态创建目标对象。

loader-当前对象的类加载器

interfaces-对象实现的接口类型

InvocationHandler-执行目标对象方法时候会触发事情处理器，把当前执行的目标对象方法作为参数传入。

```java
static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h )
```

示例：在上面spring下的文件夹里。

### CGLIB动态代理

cglib就不需要实现接口，而是在内存创建一个子类对象从而事先目标功能的扩展。因为是通过实现子类，所以代理的类不能为final，否则会报错java.lang.IllegalArgumentException.如果目标对象的方法为final或者static就不会被拦截。

示例：在上面spring下的文件夹里

### jdk代理与cglib代理比较

jdk代理是JDK原生的；必须要实现接口，而且也只能解决实现接口的动态代理。

cglib代理在字节码的基础上，目标对象必须是非final的，方法也有相应的子父类继承的限制，非final非static。

jdk更快。
