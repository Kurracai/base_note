# Mysql

## 基本概念

关系型数据库；

## 查询流程

整体执行流程如下：

![1722349527171.png](./1722349527171.png)

* 客户端发送一条查询给服务器
* 服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果（一般是 K-V 键值对），否则进入下一阶段
* 分析器进行 SQL 分析，再由优化器生成对应的执行计划
* 执行器根据优化器生成的执行计划，调用存储引擎的 API 来执行查询
* 将结果返回给客户端

大多数情况下不建议使用查询缓存，因为查询缓存往往弊大于利

* 查询缓存的**失效非常频繁**，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能费力地把结果存起来，还没使用就被一个更新全清空了，对于更新压力大的数据库来说，查询缓存的命中率会非常低
* 除非业务就是有一张静态表，很长时间才会更新一次，比如一个系统配置表，那这张表上的查询才适合使用查询缓存

### 分析器

没有命中查询缓存，就开始了 SQL 的真正执行，分析器会对 SQL 语句做解析。

处理语法和解析查询，生成对应的解析树。

* 先做**词法分析**，输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么代表什么。从输入的 select 这个关键字识别出来这是一个查询语句；把字符串 t 识别成 表名 t，把字符串 id 识别成列 id
* 然后做**语法分析**，根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果语句不对，就会收到 `You have an error in your SQL syntax` 的错误提醒

预处理器：进一步检查解析树的合法性，比如数据表和数据列是否存在、别名是否有歧义等

### 优化器

#### 成本分析

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序

* 根据搜索条件找出所有可能的使用的索引
* 成本分析，执行成本由 I/O 成本和 CPU 成本组成，计算全表扫描和使用不同索引执行 SQL 的代价
* 找到一个最优的执行方案，用最小的代价去执行语句

在数据库里面，扫描行数是影响执行代价的因素之一，扫描的行数越少意味着访问磁盘的次数越少，消耗的 CPU 资源越少，优化器还会结合是否使用临时表、是否排序等因素进行综合判断

#### 统计数据

MySQL 中保存着两种统计数据：

* innodb_table_stats 存储了表的统计数据，每一条记录对应着一个表的统计数据
* innodb_index_stats 存储了索引的统计数据，每一条记录对应着一个索引的一个统计项的数据

MySQL 在真正执行语句之前，并不能精确地知道满足条件的记录有多少条，只能根据统计信息来估算记录，统计信息就是索引的区分度，一个索引上不同的值的个数（比如性别只能是男女，就是 2 ），称之为基数（cardinality），**基数越大说明区分度越好

本身通过采样统计来筛选索引。

#### 错选索引

采样统计本身是估算数据，或者 SQL 语句中的字段选择有问题时，可能导致 MySQL 没有选择正确的执行索引

解决方法：

* 采用 force index 强行选择一个索引

  ```sql
  SELECT * FROM user FORCE INDEX(name) WHERE NAME='seazean';
  ```
* 可以考虑修改 SQL 语句，引导 MySQL 使用期望的索引
* 新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引

### 执行器

开始执行的时候，要先判断一下当前连接对表有没有**执行查询的权限**，如果没有就会返回没有权限的错误，在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。如果有权限，就打开表继续执行，执行器就会根据表的引擎定义，去使用这个引擎提供的接口

### 引擎层

Server 层和存储引擎层的交互是**以记录为单位的**，存储引擎会将单条记录返回给 Server 层做进一步处理，并不是直接返回所有的记录

工作流程：

* 首先根据二级索引选择扫描范围，获取第一条符合二级索引条件的记录，进行回表查询，将聚簇索引的记录返回 Server 层，由 Server 判断记录是否符合要求
* 然后在二级索引上继续扫描下一个符合条件的记录

## 索引

### 索引类型

### 索引失效

## sql优化

## 数据库事务

## 单表操作

### SQL分类：

- DDL（Data Definition Language）数据定义语言
  - 用来定义数据库对象：数据库，表，列等。关键字：create、drop,、alter 等
- DML（Data Manipulation Language）数据操作语言
  - 用来对数据库中表的数据进行增删改。关键字：insert、delete、update 等
- DQL（Data Query Language）数据查询语言
  - 用来查询数据库中表的记录(数据)。关键字：select、where 等
- DCL（Data Control Language）数据控制语言
  - 用来定义数据库的访问权限和安全级别，及创建用户。关键字：grant， revoke等

### 函数

#### 聚合函数

- COUNT(列名)统计数量（一般选用不为 null 的列）

- MAX(列名)最大值

- MIN(列名)最小值

- SUM(列名)求和

- AVG(列名)平均值（会忽略 null 行）

#### 文本函数

* LENGTH计算字符串长度函数，返回字符串的字节长度
* CONCAT合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个
* INSERT替换字符串函数
* LOWER将字符串中的字母转换为小写
* UPPER将字符串中的字母转换为大写
* LEFT从左侧字截取符串，返回字符串左边的若干个字符
* RIGHT从右侧字截取符串，返回字符串右边的若干个字符
* TRIM删除字符串左右两侧的空格
* REPLACE字符串替换函数，返回替换后的新字符串
* SUBSTRING截取字符串，返回从指定位置开始的指定长度的字符换
* REVERSE字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串

#### 数字函数

- ABS求绝对值
- SQRT求二次方根
- MOD求余数
- CEIL 和 CEILING两个函数功能相同，都是返回不小于参数的最小整数，即向上取整
- FLOOR向下取整，返回值转化为一个BIGINT
- RAND生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列ROUND对所传参数进行四舍五入
- SIGN返回参数的符号
- POW 和 POWER两个函数的功能相同，都是所传参数的次方的结果值
- SIN求正弦值ASIN求反正弦值，与函数 SIN 互为反函数COS求余弦值ACOS求反余弦值，与函数 COS 互为反函数TAN求正切值ATAN求反正切值，与函数 TAN 互为反函数COT求余切值

#### 日期函数

- CURDATE 和 CURRENT_DATE两个函数作用相同，返回当前系统的日期值
- CURTIME 和 CURRENT_TIME两个函数作用相同，返回当前系统的时间值
- NOW 和  SYSDATE两个函数作用相同，返回当前系统的日期和时间值
- MONTH获取指定日期中的月份
- MONTHNAME获取指定日期中的月份英文名称
- DAYNAME获取指定曰期对应的星期几的英文名称
- DAYOFWEEK获取指定日期对应的一周的索引位置值
- WEEK获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53
- DAYOFYEAR获取指定曰期是一年中的第几天，返回值范围是1~366~
- DAYOFMONTH获取指定日期是一个月中是第几天，返回值范围是1~31
- YEAR获取年份，返回值范围是 1970〜2069
- TIME_TO_SEC将时间参数转换为秒数
- SEC_TO_TIME将秒数转换为时间，与TIME_TO_SEC 互为反函数
- DATE_ADD 和 ADDDATE两个函数功能相同，都是向日期添加指定的时间间隔
- DATE_SUB 和 SUBDATE两个函数功能相同，都是向日期减去指定的时间间隔
- ADDTIME时间加法运算，在原始时间上添加指定的时间
- SUBTIME时间减法运算，在原始时间上减去指定的时间
- DATEDIFF获取两个日期之间间隔，返回参数 1 减去参数 2 的值
- DATE_FORMAT格式化指定的日期，根据参数返回指定格式的值
- WEEKDAY获取指定日期在一周内的对应的工作日索引

#### 正则查询

```mysql
SELECT * FROM emp WHERE name REGEXP '^T';	-- 匹配以T开头的name值
SELECT * FROM emp WHERE name REGEXP '2$';	-- 匹配以2结尾的name值
SELECT * FROM emp WHERE name REGEXP '[uvw]';-- 匹配包含 uvw 的name值
```

- ^在字符串开始处进行匹配
- $在字符串末尾处进行匹配
- .匹配任意单个字符, 包括换行符
- [...]匹配出括号内的任意字符
- [^...]匹配不出括号内的任意字符
- a*匹配零个或者多个a(包括空串)
- a+匹配一个或者多个a(不包括空串)
- a?匹配零个或者一个a
- a1\|a2匹配a1或a2
- a(m)匹配m个a
- a(m,)至少匹配m个a
- a(m,n)匹配m个a 到 n个a
- a(,n)匹配0到n个a
- (...)将模式元素组成单一元素

#### 排序、分组

排序查询语法：

SELECT 列名 FROM 表名 [WHERE 条件] ORDER BY 列名1 排序方式1,列名2 排序方式2;

分组查询语法：

SELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式];

```mysql
-- 按照品牌分组，获取每组商品的总金额
SELECT brand,SUM(price) FROM product GROUP BY brand;

-- 对金额大于4000元的商品，按照品牌分组,获取每组商品的总金额
SELECT brand,SUM(price) FROM product WHERE price > 4000 GROUP BY brand;

-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的
SELECT brand,SUM(price) AS getSum FROM product WHERE price > 4000 GROUP BY brand HAVING getSum > 7000;

-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的、并按照总金额的降序排列
SELECT brand,SUM(price) AS getSum FROM product WHERE price > 4000 GROUP BY brand HAVING getSum > 7000 ORDER BY getSum DESC;
```

分组规定：

* GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前
* NULL 的行会单独分为一组
* 大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型

#### 分页查询

语法：

```mysql
SELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式] LIMIT 开始记录数,查询条数;
```

```mysql
SELECT * FROM product LIMIT 0,2; 
SELECT * FROM product LIMIT 2,2; 
SELECT * FROM product LIMIT 4,2; 
SELECT * FROM product LIMIT 6,2; 
```

## 多表操作

### 约束

#### 约束分类

- PRIMARY KEY主键约束
- PRIMARY KEY AUTO_INCREMENT主键、自动增长
- UNIQUE唯一约束
- NOT NULL非空约束
- FOREIGN KEY外键约束
- FOREIGN KEY ON UPDATE CASCADE外键级联更新
- FOREIGN KEY ON DELETE CASCADE外键级联删除

#### 主键约束

* 主键约束默认包含**非空和唯一约束**两个功能
* 一张表只能有一个主键
* 主键一般用于表中数据的唯一标识

#### 唯一约束

唯一约束：约束不能有重复的数据

#### 外键约束

外键约束：让表和表之间产生关系，从而保证数据的准确性

```mysql
ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名);
```

例如：

```mysql
-- 创建user用户表
CREATE TABLE USER(
	id INT PRIMARY KEY AUTO_INCREMENT,    -- id
	name VARCHAR(20) NOT NULL             -- 姓名
);
-- 添加用户数据
INSERT INTO USER VALUES (NULL,'张三'),(NULL,'李四'),(NULL,'王五');

-- 创建orderlist订单表
CREATE TABLE orderlist(
	id INT PRIMARY KEY AUTO_INCREMENT,    -- id
	number VARCHAR(20) NOT NULL,          -- 订单编号
	uid INT,                              -- 订单所属用户
	CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)   -- 添加外键约束
);
-- 添加订单数据
INSERT INTO orderlist VALUES (NULL,'hm001',1),(NULL,'hm002',1),
(NULL,'hm003',2),(NULL,'hm004',2),
(NULL,'hm005',3),(NULL,'hm006',3);

-- 添加一个订单，但是没有所属用户。无法添加
INSERT INTO orderlist VALUES (NULL,'hm007',8);
-- 删除王五这个用户，但是订单表中王五还有很多个订单呢。无法删除
DELETE FROM USER WHERE NAME='王五';
```

#### 外键级联

级联操作：当把主表中的数据进行删除或更新时，从表中有关联的数据的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION

* RESTRICT 和 NO ACTION相同， 是指限制在子表有关联记录的情况下， 父表不能更新
* CASCADE 表示父表在更新或者删除时，更新或者删除子表对应的记录
* SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL

添加级联更新

```mysql
ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名) ON UPDATE [CASCADE | RESTRICT | SET NULL];
```

添加级联删除

```mysql
ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名) ON DELETE CASCADE;
```


### 连接

#### 内连接

inner join，笛卡尔积

SELECT 列名 FROM 表名1 [INNER] JOIN 表名2 ON 条件;

#### 外连接

left join;right join

 ![1722353185174.png](./1722353185174.png)

#### 关联查询

自关联查询：同一张表中有数据关联，可以多次查询这同一个表

#### 原理

### 嵌套

查询语句中嵌套了查询语句，**将嵌套查询称为子查询**，FROM 子句后面的子查询的结果集称为派生表.

结果是单行单列

```mysql
SELECT 列名 FROM 表名 WHERE 列名=(SELECT 列名/聚合函数(列名) FROM 表名 [WHERE 条件]);
```

结果是多行单列

```mysql
SELECT 列名 FROM 表名 WHERE 列名 [NOT] IN (SELECT 列名 FROM 表名 [WHERE 条件]);
```

结果是多行多列,查询的结果可以作为一张虚拟表参与查询

```mysql
SELECT 列名 FROM 表名 [别名],(SELECT 列名 FROM 表名 [WHERE 条件]) [别名] [WHERE 条件];

-- 查询订单表orderlist中id大于4的订单信息和所属用户USER信息
SELECT 
	* 
FROM 
	USER u,
	(SELECT * FROM orderlist WHERE id>4) o 
WHERE 
	u.id=o.uid;
```

### 联合查询

UNION 是取这两个子查询结果的并集，并进行去重，同时进行默认规则的排序（union 是行加起来，join 是列加起来）

UNION ALL 是对两个结果集进行并集操作不进行去重，不进行排序

```mysql
(select 1000 as f) union (select id from t1 order by id desc limit 2); #t1表中包含id 为 1-1000 的数据
```

语句的执行流程：

* 创建一个内存临时表，这个临时表只有一个整型字段 f，并且 f 是主键字段
* 执行第一个子查询，得到 1000 这个值，并存入临时表中
* 执行第二个子查询，拿到第一行 id=1000，试图插入临时表中，但由于 1000 这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行
* 取到第二行 id=999，插入临时表成功
* 从临时表中按行取出数据，返回结果并删除临时表，结果中包含两行数据分别是 1000 和 999

## 高级结构

### 视图

### 存储过程

### 触发器

## 存储引擎

## 系统优化

## 锁机制

## 主从

# redis

## nosql

## 数据库

### 过期删除

### 键空间

### 排序机制

## 数据结构

## 数据类型

## 持久机制

## 事务机制

## lua脚本

## 分布式锁

## 主从赋值

## 集群模式

## 其他操作

### 发布订阅

### 解决方案

#### 缓存方案
