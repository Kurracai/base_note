# 简介

JDK：java程序设计语言、Javac、Java类库、Java虚拟机，Java开发工具包

JRE：Java虚拟机+Java类库，Java运行环境

JavaEE-Java企业版,JavaSE-Java标准版,JavaME - JDK版本

Oracle JDK与OpenJdk：一个商用一个开源，二者之间的差距很小。

HotSpot：某种虚拟机（还有classic，Harmony(Apache)等）

# 内存区域

## 概述

虚拟机自动内存管理机制使得不需要为每一个new操作写delete/free代码，不容易出现内存泄漏与溢出问题。

## 运行时数据区域

### 线程隔离区

#### Java虚拟机栈

每个Java方法执行的时候JVM都会创建一个栈帧，用于存储局部变量表，操作数栈，动态连接等信息。方法从调用到执行完毕意味着入栈到出栈。

局部变量表：存放编译期可知的各种Java虚拟机基本数据类型、对象引用，以局部变量槽表示存储空间。进入一个方法时，方法需要占用的局部变量槽数量是不会变化的。

当线程请求的栈深度大于虚拟机所允许的深度时，会抛出StackOverFlow异常。如果Java虚拟机栈容量可动态扩展，当栈扩展到无法申请足够内存时会抛出OutOfMemory异常。(HotSpot虚拟机栈容量不可动态扩展，不会出现OutOfMemory情况）

#### 本地方法栈

与Java虚拟机栈概念类似。不过Java虚拟机栈执行的Java（字节码）方法，本地方法栈则是为虚拟机适用的本地方法（C，C++，汇编编写的，比较底层的方法）服务。同样存在虚拟机栈的问题。并且他的具体实现方式可以按需要实现，比如有的（Hot-Spot）会把本地方法栈和虚拟机栈合二为一。

#### 程序计数器

记录当前线程执行的字节码的行号指令，每条线程都有一个独立的程序计数器，用于在单核cpu切换线程的时候能恢复到正确位置。不会出现OutOfMemory情况。

### 线程共享区

#### 方法区

用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。（永久代-因为HotSpot虚拟机将收集器的分代扩展到了方法去，或者说使用永久代实现方法区，JDK8中已经废弃了永久代的说法，而是使用在本地内存中实现的元空间），会抛出OutOfMemoryError的异常。

**运行时常量池**-方法区的一部分，用于存放编译器生成的各种字面量和符号引用，将在类加载后存放到运行时常量池。也会抛出OutOfMemoryError的错误

#### 堆

用于存储对象实例；是垃圾收集器管理的区域，堆既可以是固定的也可以是可扩展的，会抛出OutOfMemoryError的异常

### 直接内存

会导致OutOfMemoryError但不属于运行时数据区的一部分。这是NIO引入了一种基于通道和缓冲区的IO方式，可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆中的对象作为这部分内存的引用进行操作。避免在Java堆和Native堆中来回复制。（分配可供堆内直接操作的堆外引用）

## 虚拟机堆中对象分配、布局和访问的全过程

### 对象创建

1 jvm遇到new指令，先检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否被加载、解析初始化过，没有则先进行类加载过程。之和为新生对象分配内存，内存大小在类加载完成后就确定了。

**内存分配方式：**

- 指针碰撞-规整的Java堆，有新对象指针就往空闲方向移动（仅限于垃圾回收器会将空闲区与分配区分开-空间压缩整理能力。例如serial，parnew）
- 空闲列表-维护一个列表，列表记录哪些内存块可用。（对于cms这种基于清除算法的垃圾收集器，只可以用空闲列表分配）

内存分配的并发问题

- 对分配内存空间做同步处理，CAS配上失败重试
- 每个线程在堆中预分配一块内存，本地线程分配缓冲，只在本地缓存用完需要分配新的内存区时才需要同步。

2 在内存分配完以后，将分配到的内存空间初始化为0。

3 对对象进行必要设置，如何找到对象元数据，对象是哪个类的实例，对象的GC年龄，这些在对象的对象头（对象头根据是否启用偏向锁等有不同的设置方式）中，对象哈希码（调用hashcode时候才会计算）。

4 构造函数的执行。

### 对象内存布局

对象在堆中的布局可以分为：对象头、实例数据、对齐填充。

**对象头**

- MarkWord-存储对象自身运行时数据-哈希码、GC年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳
- 类型指针-对象指向他的类型元数据的指针，可以找到对象是哪个类的实例。
- 如果对象是一个Java数组，对象头中还要有一块用于记录数组长度的数据。否则无法通过元数据信息推断出数组的大小。
- markword存储内容，32个比特，25个存储哈希，4个存储分代年龄，2个存储锁标志位。![1720622307744.jpeg](./1720622307744.jpeg)

**类的元数据**-加载完类以后除了会生成一个Class类对象，还会在方法区生成一个类的字节码二进制数据（方法代码、变量名、方法名、访问权限等）

**实例数据**

- 各个类型的字段内容

**对齐填充**-不一定需要存在的

#### 对象访问定位

可以通过栈上referrence数据操作堆上的具体对象，只是一个引用，具体定位方式取决于虚拟机。

- 句柄访问，堆中会分配句柄池。一个referrence指向的句柄池对象，两个指针一个指向堆中实例池的对象实例数据，一个指向方法区的对象类型数据。 ![1720622964610.png](./1720622964610.png)
- 直接访问，reference存储的就是对象地址。 ![1720622941656.png](./1720622941656.png)

好坏，句柄访问多了一个存储空间，但是在移动对象时候只需要改变句柄池中的数据。直接访问开销小。HotSpot采用直接访问的方式。

### OutOfMemoryError实战

#### java堆内存溢出报错 Java heap space

可能由内存溢出或者内存泄漏两种原因导致。

内存溢出：

创建了大量对象，这些对象占据了大量内存导致垃圾回收器无法及时回收。（程序处理大量数据；短时间创建大量对象；缓存数据过多）。

增加堆内存大小；优化高内存消耗处的代码。

内存泄漏：

对象不再使用但仍然被引用，无法被垃圾回收。（应用程序逻辑错误导致对象引用无法解除；不恰当使用第三方库导致对象引用未释放；持有长时间引用的静态集合类未清理）。

使用内存分析工具，查看泄露对象的引用路径找到内存泄漏的对象和代码位置。避免在长生命周期对象中持有短生命周期对象的引用。

#### 虚拟机栈与本地方法栈不足

可能由线程请求栈深度大于虚拟机允许的最大深度，StackOverFlowError

如果虚拟机栈内存运行动态扩展，当扩展栈无法申请到足够内存时候就会报OutOfMemoryError。（HotSpot无法动态扩展，所以不会报这个错误）

#### 方法区与运行时常量池

自JDK7起，原本存在于永久代的字符串常量池被移动到了Java堆中。

在JDK6中限制方法区容量，并循环生成String会报错，OutOfMemoryError:PermGen Space

之后的只有在JDK7及以上中限制堆的容量，循环生成String报错，OutOfMemoryError:Java heap space.

String的intern()方法，会在当前类常量池中查找是否存在于str等值的String如果存在就直接返回这个String的引用，不存在则在常量池中创建一个String并返回引用。

详情可以看到第98页，上面有提单jdk6与7中的intern，因为6中的intern()是永久代的引用，而StringBuilder的toString是堆上的所以不可能相等。而在7中都移到了堆，所以对第一种是相等的，第二种java在一开始就已经移进去了所以会不相等。

方法区-产生大量类来填充直到溢出即可。

JDK8以后永久代便退出了，元空间作为替代者，所以很难让虚拟机出现方法区溢出的异常。但可以设置元空间的最大值，MaxMetaspaceSize

#### 本机直接内存溢出

直接内存由MaxDirectMemorySize指定，由直接内存导致的内存溢出，不会再heap文件看到异常情况。如果内存溢出后dump文件很小，程序又直接或简介使用了DirectMemory，可以检查下这部分内容。

**直接内存**：由ByteBuffer.allocateDirect()分配的内存，由操作系统管理而不是JVM。分配释放的开销大，但是读写性能高。通过减少Java堆与本地内存直接的拷贝次数，对于大数据量如网络文件读写，直接内存可以提升效率。需要显示管理；不受jvm回收机制管理需要手动释放
**堆内存**：由JVM管理，易于使用，垃圾回收及自动管理。对于频繁的IO操作，会有性能瓶颈，因为需要在堆内存和本地内存之间拷贝。

**二者关系**：互补混合使用

# 垃圾收集机制

## 概述

机制管理范围：

堆与方法区。因为程序计数器、虚拟机栈、本地方法栈随着线程或者方法结束时候就自然回收了。

关注的事情：

- 哪些需要回收？
- 什么时候回收？
- 如何回收？

直接调用System.gc()可以触发垃圾回收

## 哪些对象需要回收

### 引用计数法

在对象中添加一个引用计数器，每当有地方引用他就+1，引用失效就-1，当计数=0时候对象就不可再使用。但这种简单的计数无法解决循环引用的问题。Java虚拟机也不是通过这种方式判断对象是否存活。

### 可达性分析算法

通过一系列叫做GC Roots的跟对象作为起点，根据引用关系向下找路径（引用链）。如果对象到GCRoots之间没有任何引用链就说明这个对象不可达/不可被使用。

**GCRoots**:

- 虚拟机栈（栈帧中的本地变量表）引用的对象，各个线程方法中用到的参数、局部遍历、临时变量
- 方法区中类静态属性引用的对象，譬如Java中的static
- 方法区中常量引用的对象，比如字符串常量池中的引用
- 本地方法栈JNI（Native方法）中引用的对象
- Java虚拟机内部的引用，如基本数据类型的Class对象，常驻的异常对象，系统类加载器
- 所有被同步锁（synchronized）持有的对象
- 反映Java虚拟机内部情况的JMXBean、本地代码缓存等
- 有的垃圾回收器是分区域的，所以还有其他区域之间的引用。

```java
public class GCRootsExample {
    private static Object staticVar; // staticVar 是 GC Root

    public static void main(String[] args) {
        Object a = new Object(); // 对象 A
        Object b = new Object(); // 对象 B
        Object c = new Object(); // 对象 C

        staticVar = a; // staticVar 引用了 A
        a = b;         // A 引用了 B
        b = c;         // B 引用了 C

        // 现在引用链为 staticVar -> A -> B -> C
        System.gc(); // 触发 GC
    }
}

```

### 引用

**引用：**

JDK1.2之前-如果Referrence数据存储的数值代表的是另一块内存的起始地址。

JDK1.2之后

- 强引用-传统引用关系 Object obj=new Object()
- 软引用-系统将要内存溢出前，会将这类对象进行第二次回收，如果这次回收内存还不够才会抛出内存溢出异常。SoftReference
- 弱引用-对象只能生存到下一次垃圾收集发生为止。WeakReference
- 虚引用-为了在这个对象被收集器回收时收到一个系统通知.PhantomReference

强引用与弱引用对比参照文件TestReference与TestWeakReference

### 最后一次回避垃圾回收的机会

可达性分析对于不可达的对象要进行两次标记，第一次标记后会进行一次筛选，筛选条件-此对象是否有必要执行finalize方法，如果对象没有覆盖finalize或者finalize方法已经被调用过，那就没必要执行。

如果有必要执行，会放在队列中，Finalizer线程执行他们的finalize方法。如果finalize方法中关联到了引用链（将本身this复制给了对象成员）就解救了。

finalize缺点-不确定性大，无法保证调用顺序。

### 回收方法区

方法区的垃圾回收包括：废弃的常量；不再使用的类型

废弃的常量-没有任何字符串对象引用常量且没有其他地方引用也会发生垃圾回收。

不再使用的类型：

- 类的所有实例都被回收，且不存在该类以及任何派生子类
- 类加载器以及被回收。除非是可替换的类加载器否则很难达成
- 该类的java.lang.Class对象没有地方引用，无法通过反射访问该类的方法。

对满足以上三个条件只是允许被回收，而且还要加虚拟机配置才可以删除。

## 垃圾回收算法

从如何判定对象消亡的角度分为引用计数式垃圾收集以及追踪式垃圾收集。直接垃圾收集与间接垃圾收集。

### 分代收集理论

分代假说：

- 弱分代假说：绝大数对象朝生息死
- 强分代假说：熬过越多次垃圾收集的对象越难被消灭
- 跨代引用假说：跨代引用相较于同代引用是极少的。

根据前两条分代假说形成了垃圾回收器的设计原则，分区域回收，至少分成两个区域新生代和老年代，在新生代中存活对象会逐步晋升到老年代。

对于跨代引用根据第三条假说，只需要在新生代上建立一个全局数据结构（记忆集），记录老年代中的哪一部分存在跨代引用，只有包含了跨代引用的小块内存里的对象才会被加入GCRoots扫描。

**收集：**

部分收集

- 新生代收集
- 老年代收集
- 混合收集

整堆收集：对堆和方法区收集

### 标记-清除算法

标记阶段-判定哪些对象需要收集

清除阶段-回收所有被标记的对象。

缺点

- 执行效率不稳定，需要回收的对象变多就会提升时间效率。
- 容易出现碎片化空间。

### 标记-复制算法

标记阶段-标记存活的

复制阶段-将存活的复制到另外一块区域，现在这块直接清除。

案例：Appel式回收：将新生代分为Eden和两块小Survivor（8：1：1），分配使用Eden和一块Survivor，垃圾回收直接使用另外一块Survivor，剩余的清理.当Survivor不足以容纳存活对象时候，依赖老年代进行担保，这部分对象直接进入老年代。HotSpot的一些虚拟机用的就是这种

### 标记-整理算法

标记-标记存活的

整理-将存活的整理到一端，剩下的清除。

主要针对老年代，存活率较高的情况。

### 比较

标记-整理与标记-清除，移动使内存回收变复杂，不移动使得内存分配更复杂。有一种方式就是大部分时候使用标记清除，受不了再使用标记-整理。

标记整理在移动内存时候需要全部暂停，耗时比较长。标记清除也需要暂停，但时间没有那么长

## 算法细节

### 根节点枚举

必须暂停用户线程，因为需要通过快照的方式记录某一个时刻的情况。

对象上存在一个叫OopMap的数据结构存放对象引用，不需要逐个扫描方法区。

### 安全点

因为在某个对象上都存储OopMap消耗太大，所以只在特定位置（安全点）记录，所以程序必须在到达安全点后才可以暂停。

安全点选择问题：不能太少也不能太频繁。只有有长时间执行（指令序列复用），如方法调用、循环跳转等才有这种情况。

垃圾收集发生时如何跑到最近的安全点：

- 抢先式中断：先终端所有线程，没有到安全点的让他重启跑到安全点再中断。（现在几乎没有虚拟机这样做
- 主动式中断：垃圾收集器需要中断线程时，不主动操作线程，而是让设置标志位，线程会主动轮询标志，当标志为真就在最近的安全点主动挂起。标志的地方和安全点是重合的。（HotSpot将轮询操作精简至一条汇编指令）

### 安全区域

场景：当用户线程处于sleep状态时候呢？

安全区域指：再一段代码内引用关系不会发生变化，任意地方开始进行垃圾收集都是安全的。

用户线程执行到安全区域时候会标记自身，垃圾回收器无需管安全区域内线程。线程离开安全区域是会检查是否已完成了根节点枚举，完成了就继续执行；没完成就一直等待。

进入sleep/block状态以后就进入了安全区域。

### 记忆集与卡表

记忆集：新生代建立记忆集避免将整个老年代加入gc roots扫描。

精度：

- 字长精度：精确到字长，该字含跨代指针
- 对象精度：精确到对象，对象含有跨代指针
- 卡精度：精确到内存区域，使用的是卡表（记忆集的一种具体实现）

**卡表**：字节数组存储，每个元素对应一块区域，存在跨代指针将这个数组元素标为1，只需要筛选为1的数据即可

### 写屏障

HotSpot虚拟机通过写后屏障维护卡表。写屏障相当于对引用赋值的AOP切面。

伪共享问题：多线程修改相互独立变量，如果变量恰好共用一个缓存行就会彼此影响（因为缓存一致性协议（Modified\exclusive\shared\invalid）写回、无效化、同步）导致性能降低。

解决方式：添加一个判断，如果卡表为脏再去修改。（避免不必要的写操作以降低冲突概率）

**缓存一致性协议：**

modified

* 当一个处理器修改了缓存行中的数据时，会将该缓存行的状态置为Modified。
* Modified状态表示该缓存行中的数据已经被修改，与主存中的数据不一致。

exclusive

* 当一个处理器拥有某个缓存行的独占访问权限时，该缓存行的状态为Exclusive。
* Exclusive状态表示该缓存行中的数据与主存中的数据一致，并且当前处理器是唯一一个拥有该数据的处理器。

shared

* 当多个处理器共享同一个缓存行中的数据时，该缓存行的状态为Shared。
* Shared状态表示多个处理器拥有相同的缓存行数据，并且数据与主存中的数据一致。

invalid

* 当一个处理器将缓存行标记为Invalid时，表示该缓存行中的数据无效，即该数据已经过时或者失效。
* Invalid状态可能发生在某个处理器修改了数据后，其他处理器的缓存行需要更新，或者某个处理器不再需要缓存行中的数据时。

### 并发可达性分析

重点需要解决的就是对象消失的问题，也就是三色标记法（推导方法）中本来是黑色的对象错误的标记为白色。

- 赋值器插入了从黑色对象到白色对象的引用。
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

解决这两个问题需要增量更新和原始快照。

增量更新解决第一个问题：当黑色对象插入新的指向白色的引用关系时就记录下来，再以这些记录的黑色重新扫描一次。

原始快照解决第二个问题：当灰色要删除指向白色的引用关系时，将要删除的引用记录下，再重新扫描一次，按照刚开始的快照来。

## 经典垃圾收集器

![1720884318390.png](./1720884318390.png)

**并行**：多条垃圾收集器线程之间关系

**并发**：垃圾收集器与用户线程之间关系

带连线表示可以配合用。

### 新生代

#### serial

适合单核，采用标记-复制算法，需要暂停所有用户线程

![1720885105606.png](./1720885105606.png)

#### parnew

采用标记-复制，暂停所有用户线程；多线程垃圾回收。

![1720885121865.png](./1720885121865.png)

#### parallel scanvage

标记-复制；多线程；吞吐量优先；并行

存在一个参数UseAdaptiveSizePolicy，这个开关打开后会动态调整细节参数以达到设定的吞吐量。

吞吐量设置：-XX: mAXgcPauseMills

本身就存在老年代收集的收集器：PSMarkSweep但实现方式与SerialOld一样。

#### 比较

parallel scanvage关注于达到可控制的吞吐量，吞吐量=运行用户代码时间/（运行用户代码时间+运行垃圾收集器时间）

cms关注尽可能缩短用户线程的停顿时间

### 老年代

#### CMS

#### SERIAL OLD

标记-整理。

![1720885105606.png](./1720885105606.png)

#### PARALLEL OLD

paraller scanvage收集器的老年版本

标记-整理

![1720885757850.png](./1720885757850.png)

#### cms

基于标记-清除。优点：并发收集。低停顿

**步骤：**

- 初始标记-标记与GCRoots直接关联引用的对象
- 并发标记-根据对象开始遍历整个GCRoots调用链
- 重新标记-使用增量更新修正新引用
- 并发清除-并发清除已经死亡的对象，不需要移动

![1720885964614.png](./1720885964614.png)

缺点：

- CMS堆处理器资源很敏感，并发阶段会占用线程
- 无法处理浮动垃圾（并发标记和重新标记阶段产生的垃圾对象）
- 需要预留内存给用户线程使用，不能像其他收集器引用等待老年代满了再收集
- 存在空间碎片（一个jdk9以后失效的参数-用于指定n次垃圾回收以后进行碎片整理）

不用记：因为CMS于hotspot内存管理、执行等各个子系统关联紧密不符合解耦，规划jdk10时统一垃圾回收接口，cms等都做了重构

### 兼具

#### G1

**特点**

JDK9以后，取代Parallerscanvage+paralellold成为服务端默认的垃圾收集器。

停顿时间模型-支持再M毫秒时间长度上消耗在垃圾收集上不超过N毫秒的目标。

面向堆的任何部分组成回收集（Mixed gc），基于Region（每个Region按需要扮演Eden，Survivor或者老年代角色，对不同Region采取不同措施，还有针对大对象（超过Region大小一般）的Humonogous区域）的堆内布局。

价值优先：跟踪各个Region里回收空间获得的大小以及回收所需时间，维护一个回收优先级。

可以由用户指定停顿时间

整体：标记-整理；局部：标记-复制

**问题及解决方案**

跨Region引用：每个Region维护一个记忆集（key是其他Region起始地，value是卡表索引），Region是记录了双向的引用关系。

并发的标记问题：G1采用原始快照的方式，并创建两个指针，在这两个指针内记录并发阶段的新对象分配

停顿预测模型：衰减均值，记录每个Region的回收耗时、脏卡数量等分析出相应指标。回收哪些Regioin才能在不超过期望停顿时间下获得最高预期。

**步骤**

- 初始标记：标记与GCRoots直接相连的对象。
- 并发标记：做可达性分析，扫描完以后还要对SATB指针内的记录做处理。
- 最终标记：处理并发阶段遗留的记录。
- 筛选回收：排序Region的回收价值，并指定回收计划。

![1720887714508.png](./1720887714508.png)

#### cms与G1比较

- G1不会产生大量内存碎片
- 可以指定停顿时间
- G1的额外负载更高
- G1的卡表实现更复杂，而且所有Region都有卡表
- 需要使用写后更新卡表，G1还需要使用写前屏障跟踪并发时指针变化情况。
- G1原始快照可以避免像CMS那样在最终标记阶段停顿时间过长。

#### 总比较

CMS和G1之前的垃圾收集器都会全部停止用户线程，而cms最终依然要做空间碎片的整理还是要暂停。

### 低延迟垃圾收集器

垃圾收集器标准：内存占用、吞吐量（用户代码运行时间占总时间比重）、延迟（停顿时间）

例子：ZGC/Shenandoah，只有初始标记和最终标记由短暂停顿，且停顿时间固定。

#### Shenandoah

基于Region；存在大对象存储；回收价值最高

与G1不同处：支持并发整理，G1回收是并行的但不是并发的；默认不使用分代；放弃了记忆集改用连接矩阵（RegionN有对象指向RegionM，则在矩阵打上标记）记录引用关系。

阶段：

- 初始标记，与G1一样，标记与GC Roots直接相连
- 并发标记，与G1一样，标记全部可达
- 最终标记，与G1一样，原始快照处理新对象
- 并发清理，清理整个区域一个存活对象都没有的Region
- 并发回收。核心差异在于他是用到标记-复制到其他未使用的Region，而且还在移动过程中保证了并发让用户线程可以访问。（通过读屏障以及转发指针）
- 初始引用更新。并发回收后将堆中指向旧对象的引用指向新地址的准备工作，建立一个线程集合点，保证所有收集器线程已经完成了移动任务。造成短暂停顿。
- 并发引用更新。真正开始进行引用更新。
- 最终引用更新。修正存在于GC Roots的引用，最后一次停顿，只与GCroots数量相关
- 并发清理。所有Region都没有存活对象。

**并发回收工作：**

在原有对象布局结构前加一个引用字段，不移动时，该引用指向自己。移动后，将该字段指向新副本。

会存在并发问题。

- 收集器线程复制了副本
- 用户线程更新了字段
- 收集器线程更新转发字段的引用值为新地址

如果事件2发生在1，3之前的话，用户访问操作在旧的对象上。所以这里收集器线程与用户线程的访问只有一个能成功，采用CAS，避免交替进行。

为了实现转发指针，该收集器在读写屏障中加入了额外的转发处理。jdk13中计划修改读屏障的影响，由内存屏障改为基于引用访问屏障（只拦截对象数据类型为引用类型的读写操作）。

#### ZGC垃圾回收器

基于Region，分为小（容量2M）中（容量32M）大型（2M的整数倍，一个大型只会存储一个大对象）

并发整理算法，同样使用读屏障，但是是采用染色指针算法。使用了64位中的剩下可用的46位地址中的4位，来记录对象三色标记状态、是否进入重分配集（被移动过），是否只能通过finalize访问。导致他能管理的内存不超过4TB

优点：

- 一旦Region的存活对象被移走后，这个Region立马可以被回收，而不需要整个堆中指向他的引用都被修正后才能清理
- 减少内存屏障的使用数量
- 染色指针可以作为存储结构来记录更多与对象标记相关的数据。

问题：

- 操作系统、处理器是否支持
- 寻址问题，染色指针可以通过虚拟内存与实际地址之间的映射解决。

流程：

- 并发标记-标记是在指针上而不是对象上
- 并发预备重分配-统计哪些Region要被清除，每次都会扫描全部的Region
- 并发重分配-将重分配对象复制到新的Region，并且维护一个转发表记录新旧对象之间的转发关系。因为染色指针，访问时候就知道这个对象是不是在重分配了，那如果正在的话就直接根据转发表访问新地址。
- 并发重映射-修正全部旧对象的引用

比较

- 完全没有使用记忆集以及写屏障。导致对象分配速度也不会太高。低延迟的目标；内存分配与回收的竞争问题。

### 垃圾收集器权衡

应用的基础设施；JDK发行商；遗留系统，基础设施与JDK比较落后（4-6G以下的堆内存使用cms，更大点考虑G1）；无法使用商业但能使用比较新的版本注重低延迟（zgc）

### 内存分配与回收策略

对象优先在Eden分配。

大对象（长字符串；数组）直接进入老年代。

长期存活的对象进入老年代。

动态对象年龄判定（如果Survivor空间中相同年龄所有对象大小总和大于Survivor空间一半，年龄大于等于该年龄对象直接进入老年代）。

空间分配担保（老年代最大可用连续空间大于新生代所有对象空间）。JDK6之后只要老年代连续空间大于新生代对象总大小或者历次晋升的平均值就会进行MinorGC否则FullGC

# 虚拟机性能监控、故障处理工具

jstack:java堆栈跟踪根据

jhat：虚拟机堆栈转储快照分析工具

JConsole,JMC:可视化工具1

# 调优案例分析与实战

# 类文件结构

## 无关性基石

Java平台无关的基石便是字节码文件，所有的文件最后都会翻译成.class字节码文件。java是平台无关，jvm是语言无关（JRUBY和Groovy都可以转换成字节码文件后运行）。

## class类文件结构

任何一个Class文件都对应着唯一一个类或接口的定义信息。

Class文件采用类型C语言结构体的伪结构来存储数据，这种伪结构只有无符号数（u1,u2,u4,u8）和表（由多个无符号数或者其他表组成的复合数据类型，所有表都以_info结尾，整个Class就是一个表）。这里与Java的伪泛型无关。

### 魔数与class文件版本

头四个字节-魔数，确定文件是否为C虚拟机可以接受的Class文件。

5-8个字节，Class文件版本号。头两个为次版本号，后两个为主版本号。

### 常量池

紧接着主次版本号后面的就是常量池入口，Class文件中的资源仓库。

头两个字节为常量池容量，表示常量池中有多少个常量（常量池容量为0X0016=22说明有21个常量，只有常量池的容量计数从1开始）。

常量池中存放两大类常量：字面量和符号引用。

**字面量**

文本字符串与声明为final的常量值

**符号引用**

- 被模块导出或者开放的包
- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符
- 方法句柄和方法类型
- 动态调用点和动态常量

Java的Javac编译时候不存在连接，而是在虚拟机加载Class文件时候做动态连接（C和C++会连接目标文件解析所有符号引用生成一个可执行文件）。Class文件中不会保存各个方法、字段在内存中的布局信息。虚拟机做类加载时候，获取符号引用然后再在类创建运行时解析到具体内存地址。

常量池中的常量每一项常量都是一个表。

常量表有比如CONSTANT_Utf8_info：UTF-8编码的字符串。等总共17类

由于Class文件中方法、字段都需要CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。所以也就是length最大值，u2的65535

### 访问标志

常量池之后的两个字节代表访问标志，用于识别类活接口层次的访问信息，包括：Class是类还是接口；是否为public等。如下图

![1720951734062.png](./1720951734062.png)

### 类索引、父类索引与接口索引集合

类索引、父类索引都是u2，接口索引是一组u2。

类索引用于确定类的全限定名，父类索引用于确定父类的全限定名，除了Object以外所有类的父索引都不为0。

这些类索引指向一个类型为CONSTANT_class_info类描述符常量，然后根据该类描述符常量中的索引可以找到一个Constant_UTF8_INFO类型的常量中的全限定名字符串。

 ![1720952229963.png](./1720952229963.png)

对于接口索引

第一个u2数据是接口计数器，如果没有接口则计数值为0，那么接口索引表不占用字节。

全限定名：包名+类名。

### 字段表集合

第一个u2类型为容量计数器，记录有多少个字段。

用于描述接口或者类中声明的遍历。包括类级变量（static变量）以及实例变量（类中的属性）。

Java语言描述一个字段包含的信息：作用域(public，private，protected）；是否实例变量；可变性（final）；并发可见性（volatile,是否强制主从内存读写）;可否被序列化（transit），字段数据类型（基本类型，对象，数组），字段名称；

如字段的名字以及数据类型都只可以通过引用常量池中的常量来描述。

![1720952803072.png](./1720952803072.png)

跟随access_flag的是name_index和descriptor_index，都是对常量池项的引用，分别表示字段的简单名称以及字段和方法的描述符。

**简单名称、全限定名、描述符：**

- 全限定名就是例如java/lang/Object这个是类的全限定名，类全名中的.换成/，
- 简单名称就是(inc()的就是inc)，
- 方法和字段的描述符：字段的数据类型，方法的参数列表（数量、类型以及顺序）和返回值

 ![1720953084249.png](./1720953084249.png)

对于数组类型，比如String[][]，他的描述符就是[[Ljava/lang/String

描述符描述方法：先参数列表后返回值，按照参数的顺序放在一组小括号中，比如java.lang.String toString()为()Ljava/lang/String


字段表集合不会列出父类或者父接口中继承的字段，但有可能出现原本代码中不存在的字段，比如内部类为了保持对外部类的访问，编译器会自动添加指向外部类实例的字段。

java中字段无法重载，两个字段的数据类型、修饰符无论是否相同都要使用不同名称，但对于class文件而言只要描述符不完全相同字段重名合法。

### 方法表

包括，访问标志、名称索引、描述符索引、属性表集合。

 ![1720964882951.png](./1720964882951.png)

方法里的Java代码就放在属性表的Code属性中。

Java方法的重载-Overload：除了要与原方法一致的名称以外，还必须有一个不同的特征签名-一个方法中各个参数在常量池中的字段符号引用的集合，而返回值不再特征签名中，。以上是在Java语言中

但在Class文件中，只要描述符不一致的两个方法都可以共存。

### 属性表集合

## 字节码指令简介

Java虚拟机的指令由一个字节长度、代表某种操作含义的数字（操作码）以及气候的参数（操作数）组成。java使用的是操作数栈


# 虚拟机类加载机制

## 类加载时机


# 虚拟机字节码执行引擎

# 前端编译与优化

# 后端编译与优化

# Java内存模型与线程

# 线程安全与锁优化
